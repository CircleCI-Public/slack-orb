tag_only: &tag_only
  filters:
    tags:
      only: /.*/

version: 2.1

parameters:
  run_default_workflow:
    default: true
    type: boolean

  run_release_workflow:
    default: false
    type: boolean

  force_docker_rebuild:
    default: false
    type: boolean

  run_rollback_workflow:
    default: false
    type: boolean

  run_captain_queso:
    default: false
    type: boolean

  rollback_environment:
    type: string
    default: ''

  rollback_commit:
    type: string
    default: ''

  run_studio_manual_build:
    default: false
    type: boolean

orbs:
  build-commands: stoplight/build-commands@0.0.4
  node: circleci/node@4.0.0
  sonarcloud: sonarsource/sonarcloud@1.0.3
  nx: nrwl/nx@1.4.0
  slack: stoplight/slack-orb-stoplight@0.0.1

defaults:
  # comment
  # unable to upgrade to 16.17 due to https://github.com/facebook/jest/issues/11956
  default-node-image: &default-node-image cimg/node:16.14.2
  browsers-node-image: &browsers-node-image cimg/node:16.14.2-browsers

commands:
  get-ip-address:
    description: Prints IP address of job
    steps:
      - run:
          name: Print IP address of job
          command: wget -O - -q https://checkip.amazonaws.com
  gcloud-authenticate:
    description: Authenticates to Google Cloud and Google Container Registry
    steps:
      - run:
          name: Authenticate with cloud
          command: |
            # install Google Cloud SDK distribution
            echo $ROTATED_GCLOUD_SERVICE_KEY > $(eval echo $GCLOUD_KEY_DIR)
            gcloud config set auth/service_account_use_self_signed_jwt false || true
            gcloud config set disable_usage_reporting true || true
            gcloud auth activate-service-account --key-file=$(eval echo $GCLOUD_KEY_DIR)
  merge:
    description: Merge if branch is pr
    steps:
      - run:
          name: Merge if PR
          command: |
            TRUNK=v2
            err=0

            # setup the github user
            git config --global user.email $( git log --format='%ae' $CIRCLE_SHA1^! )
            git config --global user.name "$( git log --format='%an' $CIRCLE_SHA1^! )"

            if [ ! "$CI_PULL_REQUEST" ]; then
              exit
            fi

            # Merge current branch into master to make sure we're testing the finished artifact
            (set -x && git merge "$TRUNK" --no-edit --no-commit && git --no-pager diff --name-only --cached) || err=$?

            if [ "$err" -ne "0" ]; then
              echo
              echo -e "ERROR: Failed to merge your branch with the latest version of $TRUNK."
              echo -e "Please manually merge $TRUNK into your branch, and push the changes to GitHub."
              exit $err
            fi
  checkout-and-merge:
    description: Checkout and merge if branch is a pr
    steps:
      - checkout
      - merge
  node-install:
    description: Command to install node in order to stop using orb
    parameters:
      node_version:
        type: string
        description: Version of node to install
        default: '16.14.2'
    steps:
      - run:
          name: install node
          command: |
            # Only install nvm if it's not already installed
            NODE_PARAM_VERSION=<<parameters.node_version>>
            if command -v nvm &> /dev/null; then
                echo "nvm is already installed. Skipping nvm install.";
            else
                curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash;
                echo 'export NVM_DIR="$HOME/.nvm"' >> $BASH_ENV;
                echo '[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" --no-use' >> $BASH_ENV;
                source $BASH_ENV;
            fi

            if [ "$NODE_PARAM_LTS" = "1" ]; then
                nvm install --lts
                nvm alias default lts/*
            else
                nvm install "$NODE_PARAM_VERSION"
                nvm alias default "$NODE_PARAM_VERSION"
            fi

            echo 'nvm use default &>/dev/null' >> $BASH_ENV
      - run:
          name: install npm
          command: |
            NODE_PARAM_VERSION=latest
            if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

                  # FUNCTIONS
                  get_npm_version () {
                      if [[ "$NODE_PARAM_NPM_VERSION" == latest ]]; then
                      NPM_ORB_VERSION="$(npm view npm | sed -E 's|.*-||g' | grep latest | \
                          perl -pe 's/.*: //g' | perl -pe "s/'|,//g")"

                      echo "Latest version of NPM is $NPM_ORB_VERSION"
                      else
                      NPM_ORB_VERSION="$NODE_PARAM_NPM_VERSION"

                      echo "Selected version of NPM is $NPM_ORB_VERSION"
                      fi
                  }

                  installation_check () {
                      if command -v npm > /dev/null 2>&1; then
                      if npm -v | grep "$NPM_ORB_VERSION" > /dev/null 2>&1; then
                          echo "NPM $NPM_ORB_VERSION is already installed"
                          exit 0
                      fi
                      fi
                  }

                  get_npm_version
                  installation_check

                  if [ "$NODE_PARAM_NPM_VERSION" = latest ]; then
                  $SUDO npm install -g npm@latest > /dev/null 2>&1 || \
                      npm install -g npm@latest > /dev/null 2>&1
                  else
                  $SUDO npm install -g "npm@$NPM_ORB_VERSION" > /dev/null 2>&1 || \
                      npm install -g "npm@$NPM_ORB_VERSION" > /dev/null 2>&1
                  fi

                  # test/verify version
                  if npm -v | grep "$NPM_ORB_VERSION" > /dev/null 2>&1; then
                  echo "Success! NPM $(npm -v) has been installed to $(which npm)"
                  else
                  echo "Something went wrong; the specified version of NPM could not be installed"
                  exit 1
                  fi
      - build-commands/set_npm_token
  docker-authenticate:
    parameters:
      gcr-auth:
        type: boolean
        description: If true, authenticate with gcr
        default: false
    steps:
      - setup_remote_docker
      - run:
          name: Authenticate docker
          command: |
            if [ -z "$QUAY_PASSWORD}" ]; then
              echo "QUAY_PASSWORD must be set! Exiting..."
              exit 1
            fi

            if "<<parameters.gcr-auth>>"; then
              gcloud -q auth configure-docker
            fi

            echo "$QUAY_PASSWORD" | docker login -u="stoplight+newcircleci" --password-stdin quay.io

  get-node-modules:
    steps:
      - build-commands/set_npm_token
      - restore_cache:
          name: Restore yarn cache
          keys:
            - node16-v2-yarn-offline-cache-{{ .Environment.CACHE_VERSION }}-{{ checksum "yarn.lock" }}-{{ checksum
              "yalc.lock" }}-{{ checksum "package.json" }}
      - run:
          name: Set yarn cache dir
          command: yarn config set cache-folder "$HOME/.cache/yarn"
      - run:
          name: Run yarn
          command: |
            if [[ -f ./YARN_OFFLINE_OK ]]; then
              echo "Restored cache found, running yarn --offline"
              echo ""
              yarn --frozen-lockfile --offline
            else
              echo "Not previously cached, running yarn with network"
              echo ""
              yarn --frozen-lockfile && touch ./YARN_OFFLINE_OK
            fi
      - save_cache:
          name: Save yarn cache
          key:
            node16-v2-yarn-offline-cache-{{ .Environment.CACHE_VERSION }}-{{ checksum "yarn.lock" }}-{{ checksum
            "yalc.lock" }}-{{ checksum "package.json" }}
          paths:
            - ~/.cache/yarn
            - ./YARN_OFFLINE_OK

  initial-node-build:
    parameters:
      image-name:
        type: string
        description: The name of the docker project / quay repository without the `stoplight/` prefix
      gcr-auth:
        type: boolean
        description: If true, authenticate with gcr
        default: false
    steps:
      - checkout
      - gcloud-authenticate
      - docker-authenticate:
          gcr-auth: <<parameters.gcr-auth>>
      - merge
      - retag-if-no-change:
          image-name: <<parameters.image-name>>
      - get-node-modules
      - run:
          name: codegen
          command: |
            yarn codegen

  retag-if-no-change:
    parameters:
      image-name:
        type: string
        description: The name of the docker project / quay repository without the `stoplight/` prefix
    steps:
      - run:
          name: Retag if no change was made that requires a rebuild
          shell: /bin/bash -xoe pipefail
          command: |

            git config core.abbrev 7
            GIT_COMMIT="$(git rev-parse --short HEAD)"
            PREVIOUS_GIT_COMMIT="$(git rev-parse --short HEAD~1)"

            FILES_CHANGED=`git diff --name-only $GIT_COMMIT $PREVIOUS_GIT_COMMIT`

            # Nonbuild files include e2e tests (e2e), unit tests (__test), terraform/k8s files (^stoplight), and readmes (.*\.md)
            # This is a non-exhaustive list but should still be enough to get us started
            NON_BUILD_FILES=`echo "$FILES_CHANGED" | grep -iE '(e2e|qa|__test|^stoplight|.*\.md|cloud-functions)' || echo "none"`


            # The job will just continue if the previous commit tag doesn't exist
            if [[ "$FILES_CHANGED" == "$NON_BUILD_FILES" && "<< parameters.image-name >>" != "e2e-test-run"  &&  "<< pipeline.parameters.force_docker_rebuild >>" == false  ]]; then

              IMAGE_EXISTS=true
              docker pull "quay.io/stoplight/<<parameters.image-name>>:${PREVIOUS_GIT_COMMIT}" || IMAGE_EXISTS=false

              if [[ "${IMAGE_EXISTS}" = "true" ]]; then

                IMAGE_BASE=quay.io/stoplight/<<parameters.image-name>>

                docker tag $IMAGE_BASE:$PREVIOUS_GIT_COMMIT $IMAGE_BASE:$GIT_COMMIT
                docker tag $IMAGE_BASE:$PREVIOUS_GIT_COMMIT $IMAGE_BASE:$CIRCLE_SHA1
                docker push $IMAGE_BASE:$GIT_COMMIT
                docker push $IMAGE_BASE:$CIRCLE_SHA1

                circleci-agent step halt
              fi
            fi

            echo "Proceeding to build"

  docker-build-and-push:
    parameters:
      image-name:
        type: string
        description: The name of the docker project / quay repository without the `stoplight/` prefix
      dockerfile:
        type: string
        description: The location of the Dockerfile
        default: ''
      build-args:
        type: string
        description: Additional build args
        default: ''
    steps:
      - run: git config core.abbrev 7
      - run:
          name: Build and tag Docker image
          command: |
            GIT_COMMIT="$(git rev-parse --short HEAD)"
            GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD | sed 's/\//\./g')" # replace / with . so we can use branch name as tag
            IMAGE_BASE=quay.io/stoplight/<<parameters.image-name>>
            BUILD_ARGS="<<parameters.build-args>>"
            DOCKERFILE="<<parameters.dockerfile>>"

            docker build $BUILD_ARGS -t $IMAGE_BASE:$GIT_COMMIT -t $IMAGE_BASE:$GIT_BRANCH -t $IMAGE_BASE:$CIRCLE_SHA1 -f ${DOCKERFILE:-"infrastructure/<<parameters.image-name>>/Dockerfile"} . | while read line ; do echo "$(date)| $line"; done;
      - run:
          name: Push Docker image to Quay
          command: |
            GIT_COMMIT="$(git rev-parse --short HEAD)"
            GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD | sed 's/\//\./g')" # replace / with . so we can use branch name as tag
            IMAGE_BASE=quay.io/stoplight/<<parameters.image-name>>
            docker push $IMAGE_BASE:$GIT_COMMIT
            docker push $IMAGE_BASE:$GIT_BRANCH
            docker push $IMAGE_BASE:$CIRCLE_SHA1
      - run:
          name: Check if prod tag exist
          shell: /bin/bash -exo pipefail
          command: |
            # If we try to deploy a service for the first time then TF will
            # try to deploy the service with the prod tag before it's been
            # pushed with the prod tag for the first time.
            #
            # To solve this we'll check if we're on v2 and if the service
            # is missing a prod tag. If so, we will copy the current image to
            # the prod tag.

            if [[ "<< pipeline.git.branch >>" = "v2" ]]; then
              GIT_COMMIT="$(git rev-parse --short HEAD)"
              PROD_TAG="$(gcloud --project stoplight-dojo-production secrets versions access latest --secret prod_image-tag)"
              IMAGE_BASE="quay.io/stoplight/<<parameters.image-name>>"

              IMAGE_EXISTS=true
              docker pull "${IMAGE_BASE}:${PROD_TAG}" || IMAGE_EXISTS=false

              if [[ "${IMAGE_EXISTS}" = "false" ]]; then
                docker tag "${IMAGE_BASE}:${GIT_COMMIT}" "${IMAGE_BASE}:${PROD_TAG}"
                docker push "${IMAGE_BASE}:${PROD_TAG}"
              fi
            fi

  env-var-by-branch:
    steps:
      - run:
          name: Set env variables
          command: |
            # Tell various frameworks/reporters we're in CI
            echo "export CI=1" >> $BASH_ENV

            # Enable TestRail reporting
            echo "export TESTRAIL_HOST=https://stoplightqa.testrail.io" >> $BASH_ENV
            echo "export TESTRAIL_PROJECTID=1" >> $BASH_ENV

            # Set host for tests
            if [[ "<< pipeline.git.branch >>" == "v2" ]]; then
              echo "export SL_ENVIRONMENT=integration" >> $BASH_ENV
              echo "export SL_POSTGRES_PW=$POSTGRES_INTEGRATION_PW" >> $BASH_ENV
              echo "export NAMESPACE=default" >> $BASH_ENV
              echo "export JOB_PREFIX=integration-" >> $BASH_ENV

            elif [ "$CI_PULL_REQUEST" ]; then
              # Host is pr environment
              PR_NUMBER=`echo $CIRCLE_PULL_REQUESTS| tr "," "\n" | awk -F/ '{print $NF}' | sort -r | head -1`
              echo "export SL_ENVIRONMENT=x-$PR_NUMBER" >> $BASH_ENV
              echo "export NAMESPACE=x-$PR_NUMBER" >> $BASH_ENV

            else
              echo "We only run e2e tests on PR branches and trunk"
            fi

            source $BASH_ENV

  wait-for-jobs:
    parameters:
      job-names:
        type: string
        description: The names of the jobs to wait for
      only-current-build:
        type: boolean
        description:
          If true, only waits for jobs in current build.  Otherwise, waits for job across all builds in project.
        default: false
    steps:
      - run:
          name: Wait for jobs
          command: |
            echo "Waiting until other <<parameters.job-names>> jobs are finished"
            export ONLY_CURRENT_BUILD=<<parameters.only-current-build>>
            sh -c "chmod +x ./.circleci/wait-until-exclusive.sh && ./.circleci/wait-until-exclusive.sh <<parameters.job-names>>"
  deploy:
    parameters:
      environment:
        type: string
        description: The environment (e.g. integration or stoplightio-v2)
    steps:
      - run:
          name: Deploy new images
          no_output_timeout: 20m
          command: |
            GIT_COMMIT="$(git rev-parse --short HEAD)"

            ENVIRONMENT="<<parameters.environment>>"

            # Helm Deploy
            cd stoplight-k8s/platform
            helm -n $ENVIRONMENT upgrade $ENVIRONMENT . --values values/$ENVIRONMENT.yaml --set imageTag=$GIT_COMMIT --wait --timeout 10m0s --debug
  rollback:
    parameters:
      environment:
        type: string
        description: The environment (e.g. integration or stoplightio-v2)
    steps:
      - run:
          name: Rollback deployments
          no_output_timeout: 20m
          command: |
            ENVIRONMENT="<<parameters.environment>>"

            # Helm Deploy
            helm -n $ENVIRONMENT rollback $ENVIRONMENT --debug

executors:
  node-browsers:
    docker:
      - image: *browsers-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
  stoplight-platform:
    resource_class: large
    docker:
      - image: *browsers-node-image
      - image: cimg/postgres:12.8
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
        command: '-c sl.encryption_key=qi4rQnDb5NWoNUfMUCrBJNqxchi7uLeu'
        environment:
          POSTGRES_DB: stoplight
          POSTGRES_USER: stoplight
          POSTGRES_PASSWORD: stoplight
      - image: quay.io/stoplight/public-api:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
        environment:
          SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_APP_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_POSTGRES_URL: 'postgres://stoplight:stoplight@127.0.0.1:5432/stoplight'
          SL_APP_URL: http://stoplight-local.com:8080
          SL_HASURA_ENDPOINT: 'http://127.0.0.1:4060/v1/graphql'
          SL_LOG_LEVEL: info
          SL_MULTI_TENANT: 'true'
      - image: quay.io/stoplight/worker:$CIRCLE_SHA1
        entrypoint:
          sh -c 'echo "starting worker" && cd /home/node && until DATABASE_URL=$SL_POSTGRES_URL yarn worker
          graphile-worker --schema-only > /home/node/schemaInit; do echo "reattempting migrations"; done && echo "ran
          migrations"'
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
        environment:
          SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_APP_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_POSTGRES_URL: 'postgres://stoplight:stoplight@127.0.0.1:5432/stoplight'
          SL_INGRESS_URL: http://127.0.0.1:8080
          SL_APP_URL: http://stoplight-local.com:8080
          NODE_OPTIONS: --max_old_space_size=200
          SL_WORKER_SECRET: 00AWeJtEdm
          SKIP_STARTUP: true
      - image: quay.io/stoplight/migrate-job:$CIRCLE_SHA1
        entrypoint: sh -c 'until psql -q $HASURA_GRAPHQL_DATABASE_URL -c "select * from graphile_worker.jobs"; do echo
          waiting for migrations; sleep 1; done && /sbin/entrypoint.sh' # wait for graphile_worker.jobs to exist
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
        environment:
          TEST_GRAPHQL: 'true'
          SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_HASURA_ENDPOINT: http://127.0.0.1:4060
          HASURA_GRAPHQL_V1_BOOLEAN_NULL_COLLAPSE: 'true'
          CUSTOM_GRAPHQL_API_ENDPOINT: 'http://127.0.0.1:4075/graphql'
          HASURA_GRAPHQL_ENABLED_LOG_TYPES: 'startup, http-log, webhook-log, websocket-log, query-log'
          HASURA_GRAPHQL_LOG_LEVEL: 'warn'
          HASURA_GRAPHQL_ENABLE_TELEMETRY: 'false'
          HASURA_GRAPHQL_UNAUTHORIZED_ROLE: 'anonymous'
          HASURA_GRAPHQL_CONSOLE_ASSETS_DIR: '/srv/console-assets'
          HASURA_GRAPHQL_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          HASURA_GRAPHQL_JWT_SECRET:
            '{"type": "HS256", "key": "arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY", "claims_namespace":
            "https://stoplight.io/jwt/claims"}'
          HASURA_GRAPHQL_SERVER_PORT: 4060
          HASURA_GRAPHQL_ENABLE_CONSOLE: 'true'
          HASURA_GRAPHQL_ENABLED_APIS: 'graphql'
          HASURA_GRAPHQL_ACTIONS_HANDLER_WEBHOOK_BASEURL: http://127.0.0.1:4069/actions
          HASURA_GRAPHQL_DISABLE_CORS: 'true'
          HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL: '3000'
          HASURA_EVENT_TRIGGER_WEBHOOK: 'http://127.0.0.1/ignore'
          SL_ACTIVITY_EVENT_HANDLER_URL: 'http://service-gateway:3333/api/_/v1/activity/hasura-event-handler'
          HASURA_GRAPHQL_DATABASE_URL: 'postgres://stoplight:stoplight@127.0.0.1:5432/stoplight'
          HASURA_GRAPHQL_MIGRATIONS_DIR: '/home/node/packages/hasura/migrations'
          HASURA_GRAPHQL_METADATA_DIR: '/home/node/packages/hasura/metadata'
      - image: quay.io/stoplight/hasura:e3bf036
        entrypoint:
          sh -c "while ! nc -z localhost 5432; do echo waiting for postgres; sleep 1; done && graphql-engine serve"
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
        environment:
          SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_HASURA_ENDPOINT: http://127.0.0.1:4060/v1/graphql
          HASURA_GRAPHQL_V1_BOOLEAN_NULL_COLLAPSE: 'true'
          CUSTOM_GRAPHQL_API_ENDPOINT: 'http://127.0.0.1:4075/graphql'
          HASURA_GRAPHQL_ENABLED_LOG_TYPES: 'startup, http-log, webhook-log, websocket-log, query-log'
          HASURA_GRAPHQL_LOG_LEVEL: 'warn'
          HASURA_GRAPHQL_ENABLE_TELEMETRY: 'false'
          HASURA_GRAPHQL_UNAUTHORIZED_ROLE: 'anonymous'
          HASURA_GRAPHQL_CONSOLE_ASSETS_DIR: '/srv/console-assets'
          HASURA_GRAPHQL_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          HASURA_GRAPHQL_JWT_SECRET:
            '{"type": "HS256", "key": "arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY", "claims_namespace":
            "https://stoplight.io/jwt/claims"}'
          HASURA_GRAPHQL_SERVER_PORT: 4060
          HASURA_GRAPHQL_ENABLE_CONSOLE: 'true'
          HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE: 200
          HASURA_GRAPHQL_ENABLED_APIS: 'graphql'
          HASURA_GRAPHQL_ACTIONS_HANDLER_WEBHOOK_BASEURL: http://127.0.0.1:4069/actions
          HASURA_GRAPHQL_DISABLE_CORS: 'true'
          HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL: '3000'
          HASURA_EVENT_TRIGGER_WEBHOOK: 'http://127.0.0.1/ignore'
          SL_ACTIVITY_EVENT_HANDLER_URL: 'http://service-gateway:3333/api/_/v1/activity/hasura-event-handler'
          HASURA_GRAPHQL_DATABASE_URL: 'postgres://stoplight:stoplight@127.0.0.1:5432/stoplight'
          HASURA_GRAPHQL_MIGRATIONS_DIR: '/home/node/packages/hasura/migrations'
          HASURA_GRAPHQL_METADATA_DIR: '/home/node/packages/hasura/metadata'
      - image: quay.io/stoplight/graphql-api:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
        environment:
          SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_POSTGRES_URL: postgres://stoplight:stoplight@127.0.0.1:5432/stoplight
          SL_HASURA_ENDPOINT: http://127.0.0.1:4060/v1/graphql
          SL_APP_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
          SL_PUBLIC_API_URL: '127.0.0.1'
          SL_APP_URL: http://stoplight-local.com:8080
          SL_WORKER_SECRET: 00AWeJtEdm
          PORT: '4075'
  node-gcp-build:
    docker:
      - image: quay.io/stoplight/node-gcp-build:16.14.2-cloudflare
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
  terraform-build:
    docker:
      - image: quay.io/stoplight/terraform-build:latest
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    resource_class: stoplight/self-hosted-runner-small
jobs:
  rollback_workflow:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-medium
    steps:
      - get-ip-address
      - checkout
      - gcloud-authenticate
      - run:
          name: rollback
          command: |
            if [[ "<< pipeline.parameters.rollback_environment >>" = "prod" || "<< pipeline.parameters.rollback_environment >>" = "pre-prod" ]]; then
              PROJECT=stoplight-dojo-production
            else
              PROJECT=stoplight-dojo-integration
            fi

            python3 scripts/rollback.py -e "<< pipeline.parameters.rollback_environment >>" -c "<< pipeline.parameters.rollback_commit >>" -p "${PROJECT}"

            echo "updating << pipeline.parameters.rollback_environment >>_image-tag to match new commit: << pipeline.parameters.rollback_commit >>"
            echo -n "<< pipeline.parameters.rollback_commit >>" | gcloud secrets versions add "<< pipeline.parameters.rollback_environment >>_image-tag" --data-file=- --project="${PROJECT}"
      - slack-orb/notify:
          channel: 'feed-pipeline-deployments, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: pass
          template: rollback_success
      - slack-orb/notify:
          channel: 'feed-pipeline-deployments, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: rollback_failure

  test_failure:
    executor: node-gcp-build
    resource_class: small
    environment:
      TEST_SLACK_BOT_TOKEN: $TEST_SLACK_BOT_TOKEN
    steps:
      - run:
          name: test_failure
          command: exit 1
      - slack-orb/notify:
          channel: slack-notify
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: test-stoplight-orb
          event: fail
          template: rollback_failure

  terraform-preview:
    executor: terraform-build
    steps:
      - get-ip-address
      - checkout
      - gcloud-authenticate
      - run:
          name: Terraform plan
          command: |

            if git diff --name-only "<< pipeline.git.branch >>" v2 | grep 'stoplight-terraform\|stoplight-k8s/platform'; then

              export GOOGLE_APPLICATION_CREDENTIALS=$(eval echo $GCLOUD_KEY_DIR)

              # Check diff
              cd stoplight-terraform/$TERRAFORM_DIR
              for dir in integration pre-prod prod; do

                # Connect to correct cluster
                if [[ "$dir" = "prod" ]]; then
                  CLOUDSDK_CORE_PROJECT=stoplight-dojo-production

                else
                  CLOUDSDK_CORE_PROJECT=stoplight-dojo-integration
                fi

                gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project $CLOUDSDK_CORE_PROJECT

                # Terraform plan
                pushd $dir

                for i in $(seq 10); do terraform init && break || sleep 1; done
                for i in $(seq 10); do terraform plan -lock=false && break || sleep 1; done

                echo "\n\n\n\n\n"
                popd

              done
            else
              echo "NO TF PLAN: THIS PR DOES NOT CONTAIN CHANGES TO STOPLIGHT TERRAFORM OR HELM"
            fi

  terraform:
    parameters:
      environment:
        type: string
      action:
        type: string
    executor: terraform-build
    steps:
      - get-ip-address
      - checkout
      - run:
          command: |
            echo "$CIRCLE_WORKFLOW_ID <<parameters.environment>>"  > workflow_id.txt
      - restore_cache:
          keys:
            - terraform-plan-cache-{{ .Revision }}-{{ checksum "workflow_id.txt" }}
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            environment=<<parameters.environment>>
            echo "export environment=$environment" >> $BASH_ENV

            if [[ "$environment" = "stoplightio-v2" ]]; then
              CLOUDSDK_CORE_PROJECT=stoplight-dojo-production
              echo "export TERRAFORM_DIR=prod" >> $BASH_ENV
              echo "export approve_job_name=approve_prod_terraform" >> $BASH_ENV

            elif [[ "$environment" = "pre-prod" ]]; then
              CLOUDSDK_CORE_PROJECT=stoplight-dojo-production
              echo "export TERRAFORM_DIR=pre-prod" >> $BASH_ENV
              echo "export terraform_skip_autoapprove=true" >> $BASH_ENV

              # per michael, theres no approval job for pre-prod
              #echo "export approve_job_name=approve_prod_terraform" >> $BASH_ENV

            else
              CLOUDSDK_CORE_PROJECT=stoplight-dojo-integration
              echo "export TERRAFORM_DIR=integration" >> $BASH_ENV
              echo "export approve_job_name=approve_integration_terraform" >> $BASH_ENV
            fi

            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project $CLOUDSDK_CORE_PROJECT

      - run:
          name: Terraform action
          shell: /bin/bash -xo pipefail
          command: |
            TERRAFORM_PLAN_DIR=~/project/terraform_plan
            TERRAFORM_PLAN_FILE=update_"$TERRAFORM_DIR"_plan.tf
            export GOOGLE_APPLICATION_CREDENTIALS=$(eval echo $GCLOUD_KEY_DIR)

            # Check diff
            cd stoplight-terraform/$TERRAFORM_DIR
            for i in $(seq 10); do terraform init && break || sleep 1; done

            # Make plan directory if it doesn't exist
            if [ ! -d "$TERRAFORM_PLAN_DIR" ]; then
              mkdir $TERRAFORM_PLAN_DIR
            fi

            # Create plan if plan
            if [[ "<< parameters.action >>" == "plan" ]]; then

              # Check if change was made to k8s or terraform
              git diff --name-only HEAD^ | grep -iEq '^stoplight-(k8s|terraform)/' && terraform_change=true || terraform_change=false
              echo "terraform_change=$terraform_change"

              # Plan if change found
              if [[ $terraform_change == true ]]; then
                echo "Performing terraform plan"
                terraform plan -lock=false -detailed-exitcode -out="$TERRAFORM_PLAN_DIR/$TERRAFORM_PLAN_FILE"
                export terraform_plan_result=$?

                if [[ $terraform_plan_result == 1 ]]; then
                  echo "Terraform error"
                  exit 1
                fi
              fi

              echo "approve_job_name is $approve_job_name"

              # allow skipping autoapprove
              if [[ $terraform_skip_autoapprove != true ]]; then
                # Autoapprove if no diff or no terraform change made
                if [[ "$terraform_plan_result" -eq 0 || $terraform_change == false ]]; then
                  curl --request GET  \
                    --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/job  \
                    --header "Circle-Token: ${CIRCLE_BOT_TOKEN}" | jq -r '.items[]'

                  approve_job_id=$(curl --request GET  \
                    --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/job  \
                    --header "Circle-Token: ${CIRCLE_BOT_TOKEN}" | jq -r '.items[] | select( .name | test("'"$approve_job_name"'") ) | .approval_request_id')

                  echo $approve_job_id

                  curl --request POST \
                    --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/approve/$approve_job_id \
                    --header "Circle-Token: ${CIRCLE_BOT_TOKEN}"
                fi
              fi

            # Apply plan if it exists
            elif [[ "<< parameters.action >>" == "apply" ]]; then

              echo "Plan file dir is $TERRAFORM_PLAN_DIR/$TERRAFORM_PLAN_FILE"
              ls $TERRAFORM_PLAN_DIR

              if [ -f "$TERRAFORM_PLAN_DIR/$TERRAFORM_PLAN_FILE" ]; then
                echo "found a terraform plan file at $TERRAFORM_PLAN_DIR/$TERRAFORM_PLAN_FILE"
                terraform apply -auto-approve "$TERRAFORM_PLAN_DIR/$TERRAFORM_PLAN_FILE"
              else
                echo "No terraform plan to apply"
              fi

            fi
      - save_cache:
          name: Terraform plan cache
          key: terraform-plan-cache-{{ .Revision }}-{{ checksum "workflow_id.txt" }}
          paths:
            - ~/project/terraform_plan

  on-hold:
    executor: node-gcp-build
    resource_class: small
    parameters:
      branch_pattern:
        default: .+
        description: |
          A comma separated list of regex matchable branch names. Notifications will only be sent if sent from a job from these branches. By default ".+" will be used to match all branches. Pattern must match the full string, no partial matches.
        type: string
      channel:
        default: $SLACK_DEFAULT_CHANNEL
        description: |
          Select which channel in which to post to. Channel name or ID will work. You may include a comma separated list of channels if you wish to post to multiple channels at once. Set the "SLACK_DEFAULT_CHANNEL" environment variable for the default channel.
        type: string
      custom:
        default: ''
        description: |
          (optional) Enter a custom message template.

          1. Create your message template using the Block Kit Builder: https://app.slack.com/block-kit-builder/.
          2. Insert any desired environment variables.
          3. Paste value here.
        type: string
      mentions:
        default: ''
        description: |
          Exports to the "$SLACK_PARAM_MENTIONS" environment variable for use in templates.
          Mention users via the @ symbol: "@USER"
          If the username contains a space, the Slack ID must be used with angled brackets: "<@U8XXXXXXX>"
        type: string
      template:
        default: on_hold_v2
        description:
          (optional) By default this job will send the standard "on_hold_v2" template. In order to use a custom template
          you must also set this value to an empty string.
        type: string
    steps:
      - checkout-and-merge
      - slack-orb/notify:
          branch_pattern: <<parameters.branch_pattern>>
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          channel: <<parameters.channel>>
          custom: <<parameters.custom>>
          event: always
          mentions: <<parameters.mentions>>
          template: <<parameters.template>>

  lint-and-type-check:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run:
          name: lint
          command: yarn lint # lint does not require any built files, so we can do it early
      - run:
          name: codegen and build typescript packages
          command: |
            if [[ ! -d packages/analyzer/dist ]]; then
              yarn build.min
            fi
      - run:
          name: type-check
          command: yarn type-check # type-check before build.webpack, so we can stop early if there are issues
      - run:
          name: Fail Fast
          when: on_fail
          command: |
            echo "Canceling workflow as a step resulted in failure"
            curl --request POST \
                  --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel \
                  --header "Circle-Token: ${CIRCLE_BOT_TOKEN}"

  build-and-deploy-storybook:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run:
          name: codegen and build typescript packages
          command: |
            if [[ ! -d packages/analyzer/dist ]]; then
              yarn build.min
            fi
      - run: yarn publish.storybook --project-token=${CHROMATIC_PROJECT_TOKEN}
      - run:
          name: Fail Fast
          when: on_fail
          command: |
            echo "Canceling workflow as a step resulted in failure"
            curl --request POST \
                  --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel \
                  --header "Circle-Token: ${CIRCLE_BOT_TOKEN}"

  build_cli:
    resource_class: xlarge
    executor: node-gcp-build
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run:
          name: codegen and build typescript packages
          command: |
            if [[ ! -d packages/analyzer/dist ]]; then
              yarn build.min
            fi
      - run:
          name: build packages
          command: | # check if packages have been restored from cache
            if [[ ! -d packages/cli/dist ]]; then
              yarn update-metadata
              yarn graphql-api build && yarn public-api build && yarn worker build
              yarn cli build
            fi
      - run:
          name: Install prod dependencies
          command: yarn --production --frozen-lockfile
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    resource_class: large
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
      - image: cimg/postgres:12.8
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
        command: '-c sl.encryption_key=qi4rQnDb5NWoNUfMUCrBJNqxchi7uLeu'
        environment:
          POSTGRES_USER: stoplight
          POSTGRES_PASSWORD: stoplight
          POSTGRES_DB: stoplight
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
      MAIN_BRANCH_NAME: v2
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run:
          name: Codegen, build typescript, and update-metadata
          command: yarn build.min && yarn update-metadata

      - nx/set-shas
      - run:
          name: run tests
          command: |
            # make coverage dir in case nx doesn't run any tests
            mkdir ./coverage

            # reporters are specified in the root jest.preset.base.js files
            # parallel 3 - 3 is the number of cpu cores on resource_medium+
            if [[ "$CI_PULL_REQUEST" != "" ]]; then
              # run only tests affected by code changes on PRs
              # READONLY key in PRs, the safer option described in https://nx.app/docs/manage-access#security-concerns-and-setups
              NX_CLOUD_ACCESS_TOKEN=$NX_CLOUD_ACCESS_TOKEN_READONLY yarn test.affected --base=$NX_BASE --head=$NX_HEAD --colors --forceExit --bail 5 --parallel 3 --runInBand
            else
              # run all tests for any branch not associated with a PR
              NX_CLOUD_ACCESS_TOKEN=$NX_CLOUD_ACCESS_TOKEN_READ_WRITE yarn test --base=$NX_BASE --head=$NX_HEAD --colors --forceExit --parallel 3 --runInBand
            fi

      - store_test_results:
          path: ./reports/junit/
      - store_artifacts:
          path: ./reports/junit
      - persist_to_workspace:
          root: .
          paths:
            - ./coverage
      - run:
          name: enforce dependency rules
          command: yarn arch
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  sonarcloud-report:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    steps:
      - get-ip-address
      - checkout-and-merge
      - attach_workspace:
          at: .
      - sonarcloud/scan

  test-graphql:
    resource_class: large
    executor: stoplight-platform
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
      SL_APP_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
      SL_HASURA_ADMIN_SECRET: arlYdNY1S6wxUAFCiDELK3i2k6tPB5tzY
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run:
          name: Codegen, build typescript, and update-metadata
          command: yarn build.min && yarn update-metadata
      - run:
          name: perform schema check
          no_output_timeout: 10m
          command: |
            set -x

            # install psql
            sudo apt-get update && sudo apt-get install postgresql-client;

            # wait until migrate-job has finished
            echo "Waiting until migrations are complete..."
            LATEST_MIGRATION=$(ls packages/hasura/migrations/default | tail -n 1 | cut -d '_' -f 1);
            echo $LATEST_MIGRATION
            until psql -U stoplight -d stoplight -h 127.0.0.1 -p 5432 -c "select 1 from hdb_catalog.hdb_version where cli_state::text like '%$LATEST_MIGRATION%';" | grep -q 1; do sleep 1; done;
            echo "Done! Migration $LATEST_MIGRATION has been applied!";

            changes=$(yarn hasura diff.schema | grep "found change" || true; )
            if
              [[ -z $changes ]];
            then
              echo "Schemas are up to date!"
            else
              echo "ERROR: Detected schema changes in the following files:"
              echo $changes
              echo;echo;
              echo "To resolve, do the following:"
              echo "1. Start your dev environment with \"yarn dev\" "
              echo "2. When Hasura is up, run \"yarn hasura write.schema\""
              echo "3. Commit the changes"
              exit 1
            fi
      - run:
          name: run hasura tests
          command: yarn test.gql --reporters="default" --reporters="jest-junit" --maxWorkers=3
      - store_test_results:
          path: ./packages/hasura/
      - store_artifacts:
          path: ./packages/hasura/
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  docker-build-on-prem-init:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - build-commands/set_npm_token
      - docker-authenticate
      - docker-build-and-push:
          image-name: on-prem-init

  docker-build-stoplight-utility:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - docker-authenticate
      - docker-build-and-push:
          image-name: stoplight-utility

  docker-build-service:
    executor: node-gcp-build
    resource_class: <<parameters.executor-size>>
    description: Builds the docker image of a given service
    parameters:
      image-name:
        type: string
        description: The name of the quay repository / docker image (stoplight/X)
      package-name:
        type: string
        description:
          The name of the corresponding package/ dir to be built - usually same as image name. Set to NONE if no
          corresponding package exists
        default: ''
      gcr-auth:
        type: boolean
        description: If true, authenticate with gcr
        default: false
      executor-size:
        type: string
        description: Size of container to run as executor
        default: medium+
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - initial-node-build:
          image-name: <<parameters.image-name>>
          gcr-auth: <<parameters.gcr-auth>>
      - gcloud-authenticate
      - run:
          name: Build asset
          shell: /bin/bash -xoe pipefail
          command: |

            yarn update-metadata

            # Package name is image name unless otherwise specified
            if [[ "<<parameters.package-name>>" == "" ]]; then
              PACKAGE_NAME="<<parameters.image-name>>"
            else
              PACKAGE_NAME="<<parameters.package-name>>"
            fi

            if [[ -d packages/$PACKAGE_NAME ]]; then
              # build legacy libs (like packages/magic-portal, etc)
              yarn build.tsc

              # Build package
              yarn $PACKAGE_NAME build

              # Upload to sentry if applicable
              if cat packages/$PACKAGE_NAME/package.json | grep sentry; then

                rewrite_options="dist"
                if [[ "$PACKAGE_NAME" == "ninja" ]]; then rewrite_options="dist/public dist/server.js dist/server.js.map"; fi

                # Release sentry
                SENTRY_RELEASE=$(cat node_modules/@stoplight/metadata/index.json | jq -r .release)
                export SENTRY_ORG=stoplightio
                export SENTRY_PROJECT=$PACKAGE_NAME
                yarn $PACKAGE_NAME sentry releases new $PACKAGE_NAME@$SENTRY_RELEASE
                yarn $PACKAGE_NAME sentry releases files $PACKAGE_NAME@$SENTRY_RELEASE upload-sourcemaps --rewrite $rewrite_options
                yarn $PACKAGE_NAME sentry releases set-commits $PACKAGE_NAME@$SENTRY_RELEASE --auto
                yarn $PACKAGE_NAME sentry releases finalize $PACKAGE_NAME@$SENTRY_RELEASE
              fi
            fi

            if [[ "$PACKAGE_NAME" == "ninja" ]]; then
              # Upload static assets for ninja
              if [[ "<< pipeline.git.branch >>" == "v2" ]]; then
                BUCKET=static.stoplight-dev.com
              else
                BUCKET=static-dev.stoplight-dev.com
              fi

              cp $(eval echo $GCLOUD_KEY_DIR) packages/ninja/
              GCP_KEYFILE_PATH=$(eval echo $GCLOUD_KEY_DIR) GCP_BUCKET_NAME=$BUCKET SET_BUCKET_CORS=1 yarn ninja upload-assets
            fi

            if [[ "$PACKAGE_NAME" == "e2e-test-run" ]]; then
              yarn qa build
              PLAYWRIGHT_BROWSERS_PATH=./pw-browsers yarn run playwright install chromium
              yarn cli build
              cp -r ./.git git
            fi

      - run: git config core.abbrev 7
      - run: echo "$(git rev-parse --short HEAD)" | tee COMMIT.txt
      - run:
          name: make sure package.json is updated after on-premise releases
          command: |
            GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD | sed 's/\//\./g')"
            NEW_TAG=$(jq -r '.version' package.json)
            if git rev-parse $NEW_TAG; then
              echo "Version $NEW_TAG already exists. Please update package.json or delete tag from GitHub before running..."
              exit 1
            fi
            echo "VERSION: $NEW_TAG"
            echo "$NEW_TAG" > VERSION.txt
      - run: yarn isolate.<<parameters.image-name>>
      - run: if [[ "<<parameters.image-name>>" != "init" ]]; then yarn --prod --offline; fi
      - docker-build-and-push:
          image-name: <<parameters.image-name>>

  docker-build-microservice:
    resource_class: medium+
    description: Builds the docker image of the microservices API gateway
    parameters:
      image-name:
        type: string
        description: The name of the quay repository / docker image (stoplight/X)
      service-name:
        type: string
        description: The name of the microservice (e.g. gateway)
    executor: node-gcp-build
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - initial-node-build:
          image-name: <<parameters.image-name>>
      - run: echo "$(git rev-parse --short HEAD)" | tee COMMIT.txt
      - run:
          name: make sure package.json is updated after on-premise releases
          command: |
            GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD | sed 's/\//\./g')"
            NEW_TAG=$(jq -r '.version' package.json)
            if git rev-parse $NEW_TAG; then
              echo "Version $NEW_TAG already exists. Please update package.json or delete tag from GitHub before running..."
              exit 1
            fi
            echo "VERSION: $NEW_TAG"
            echo "$NEW_TAG" > VERSION.txt
      - run: yarn build.one services-<<parameters.service-name>> --prod
      - run:
          name: Minimize node_modules folder
          command: |
            yarn isolate.microservices
            cp ./dist/services/<<parameters.service-name>>/package.json .
            yarn --prod --offline
      - docker-build-and-push:
          image-name: <<parameters.image-name>>
          dockerfile: services/<<parameters.service-name>>/Dockerfile

  docker-build-microservice-auth-oauth:
    description: builds the OAuth component of the auth microservice
    executor: node-gcp-build
    resource_class: medium+
    environment:
      BUILDKIT_PROGRESS: plain
    working_directory: ~/platform-internal/services/auth-oauth
    steps:
      ## similar to initial-node-build
      - checkout:
          path: ~/platform-internal
      - gcloud-authenticate
      - docker-authenticate
      - merge
      - retag-if-no-change:
          image-name: stoplight-service-auth-oauth
      - docker-build-and-push:
          image-name: stoplight-service-auth-oauth
          dockerfile: Dockerfile
          # build-args: --build-arg SONAR_TOKEN=$SONAR_TOKEN

  push-on-prem-release:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-medium
    steps:
      - checkout
      - gcloud-authenticate
      - run:
          name: Install kots CLI
          command: |
            sudo REPL_INSTALL_PATH=/usr/local/bin REPL_USE_SUDO=y curl https://kots.io/install/1.96.0 | sudo bash
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration
      - run:
          name: Push on-prem release to kots
          command: |
            for env in beta qa; do
              # Check if the env exists
              if kubectl get ns on-prem-${env}; then
                # If it exists then we will upgrade the env
                kubectl kots upstream upgrade stoplight-platform --namespace on-prem-${env}
              else
                # If the namespace does not exist then install the env
                kubectl kots install stoplight-platform --namespace on-prem-beta --license-file=.circleci/On-Prem-Automation/On-Prem-${env}.yaml --config-values=.circleci/On-Prem-Automation/config_values.yml
                kubectl -n on-prem-${env} apply -f stoplight-k8s/kots-admin-ingress/${env}-ingress.yaml
              fi
            done

  bless_image:
    executor: node-gcp-build
    resource_class: small
    parameters:
      blessed-image-tag:
        type: string
        description: New tag for blessed image
      gcp-image-secret:
        type: string
        description: Name of tag secret name in gcp
      gcp-project:
        type: string
        description: Name of gcp project where secret stored
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - setup_remote_docker
      - gcloud-authenticate
      - run:
          name: Tag platform and update image secret
          command: |
            GIT_COMMIT="$(git rev-parse --short HEAD)"
            NEW_TAG="<<parameters.blessed-image-tag>>"
            GCP_SECRET_NAME="<<parameters.gcp-image-secret>>"
            GCP_PROJECT="<<parameters.gcp-project>>"

            echo "$QUAY_PASSWORD" | docker login -u="stoplight+newcircleci" --password-stdin quay.io
            docker pull quay.io/stoplight/init:$GIT_COMMIT
            docker tag quay.io/stoplight/init:$GIT_COMMIT quay.io/stoplight/init:$NEW_TAG
            docker push quay.io/stoplight/init:$NEW_TAG

            printf "$GIT_COMMIT" | gcloud --project $GCP_PROJECT secrets versions add $GCP_SECRET_NAME --data-file=-

            # tag commit with "production-v2" in github
            if [ "$NEW_TAG" == "production-v2" ]; then
              git remote remove origin
              git remote add origin https://stoplight-bot:$GH_TOKEN@github.com/stoplightio/platform-internal.git
              git config user.email "support@stoplight.io"
              git config user.name "Stoplight Bot"
              git tag -f production-v2
              git push -f origin production-v2
            fi

  deploy_integration:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration
            kubectl config set-context --current --namespace=integration
      - run:
          name: make sure this isn't a rollback
          command: |
            GIT_COMMIT="$(git rev-parse --short HEAD)"
            DEPLOYED_COMMIT="$(kubectl get deployment worker -o jsonpath='{.spec.template.spec.containers[*].image}' | cut -d':' -f2)"
            if git merge-base --is-ancestor $GIT_COMMIT $DEPLOYED_COMMIT && [ $GIT_COMMIT != $DEPLOYED_COMMIT ] ; then
              echo "This commit is an ancestor of the currently deployed commit! Please contact DevOps if you're trying to rollback!"
              exit 1
            fi

      - deploy:
          environment: integration
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  rollback_integration:
    # Trigger this job manually using the following command
    # curl -u ${CIRCLECI_TOKEN}: \
    #         -d 'build_parameters[CIRCLE_JOB]=rollback_integration' \
    #        https://circleci.com/api/v1.1/project/github/stoplightio/platform-internal/tree/v2

    executor: node-gcp-build
    resource_class: small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - setup_remote_docker
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration
            kubectl config set-context --current --namespace=integration
      - rollback:
          environment: integration

      - run:
          name: finish integration rollback
          no_output_timeout: 20m
          command: |
            # TODO: Update slack notifactions to use `notify` job instead of api call here

            #Wait for successful rollout, send a slack message
            if
              OUTPUT1="$(timeout 900 kubectl rollout status -w deployment/worker | sed "s/\"/'/g")";
            then
              ROLLBACK_INTEGRATION_IMAGE=$(kubectl get deployment worker -o=jsonpath='{.spec.template.spec.containers[0].image}' | cut -d ":" -f 2)
              printf "$ROLLBACK_INTEGRATION_IMAGE" | gcloud --project stoplight-dojo-integration secrets versions add integration_image-tag --data-file=-
              echo "No timeout. Deployment was successful"
            else
              echo "integration Deployment has timed out! Sending slack message..."
              EVENTS="$(kubectl describe pod -l app.kubernetes.io/name=integration | awk -v N=2 '/Events:/{++n} n>=N' | sed '1,/Name:/!d' | sed "s/\"/'/g")"
              curl -X POST --data-urlencode 'payload={"text": "```'"$(echo "V2 INTEGRATION ROLLBACK FAILED\n\n$EVENTS\n\nCIRCLE CI BUILD:$CIRCLE_BUILD_URL\n\nCOMMIT: $(git log --pretty=format:%s -1)")"'```"}' https://hooks.slack.com/services/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 && exit 1
            fi

  publish_catalog_api_pr:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    resource_class: medium
    working_directory: ~/tmp/platform-internal
    steps:
      - get-ip-address
      - checkout
      - run: git config core.abbrev 7
      - build-commands/set_npm_token
      - attach_workspace:
          at: ~/tmp/
      - run:
          name: Install Dependencies
          command: |
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh -y
      - run:
          name: Setup custom environment variables
          command: |
            echo 'export SL_EXPORT_USER=${SL_OAS_GUEST_USERNAME}' >> "$BASH_ENV"
            echo 'export SL_EXPORT_PASSWORD=${SL_OAS_GUEST_PASSWORD}' >> "$BASH_ENV"
            echo 'export SL_GH_ACCESS_TOKEN=${GH_TOKEN}' >> "$BASH_ENV"
      - run:
          name: Create PR for Public OAS
          command: |
            git config --global user.email "support@stoplight.io"
            git config --global user.name "Stoplight Bot"
            cd ./tools/publish-public-oas-cli
            yarn install
            yarn build
            yarn start || true
          environment:
            SL_WORKSPACE_SLUG: meta
            SL_OAS_EXPORT_URL: https://stoplight.io/api/v1/projects/meta/platform-internal/nodes/services/api-design/openapi.v1.json?deref=optimizedBundle&format=yaml
            SL_OAS_GH_URL: https://stoplight-bot:${GH_TOKEN}@github.com/stoplightio/stoplight-api-docs.git

  publish_cli_integration:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    resource_class: small
    working_directory: ~/tmp/packages/cli
    steps:
      - get-ip-address
      - build-commands/set_npm_token
      - attach_workspace:
          at: ~/tmp/
      - run:
          name: Update metadata
          command: ../metadata/update.js
      - run:
          name: Publish
          command:
            | # HACKS: this uses the last "pre" version from NPM smooshed with the metadata version. there has to be a better way!
            PKG_VERSION="$(cat ../metadata/index.json | jq -r .pkg.version)"
            NEXT_NPM_VERSION="$(npx semver --preid next -i prerelease $(npm show @stoplight/cli@next version))"
            PREID_VERSION="$(echo $NEXT_NPM_VERSION | cut -d - -f 2)"
            VERSION="$PKG_VERSION-$PREID_VERSION"
            npm version "$VERSION"
            cmp --silent ./index.js ./dist/index.js || npm publish --tag next --verbose --timing

  publish_cli_stable:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    resource_class: small
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    working_directory: ~/tmp/packages/cli
    steps:
      - get-ip-address
      - checkout-and-merge
      - build-commands/set_npm_token
      - attach_workspace:
          at: ~/tmp/
      - run:
          name: Get current version
          command: wget https://unpkg.com/browse/@stoplight/cli@stable/dist/index.js
      - run:
          name: Install prod dependencies
          command: yarn --production --force
      - run:
          name: Test CLI is running properly
          command: node ./dist/index.js -h
      - run:
          name: Update metadata
          command: ../metadata/update.js
      - run:
          name: Set version number
          command: |
            VERSION="$(cat ../metadata/index.json | jq -r .release)"
            npm version "$VERSION" --no-git-tag-version
      - run:
          name: Publish
          command: npm publish --tag stable

  publish_cli_prod:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    resource_class: small
    working_directory: ~/tmp/packages/cli
    steps:
      - get-ip-address
      - build-commands/set_npm_token
      - attach_workspace:
          at: ~/tmp/
      - run:
          name: Get current version
          command: wget https://unpkg.com/browse/@stoplight/cli/dist/index.js
      - run:
          name: Test CLI is running properly
          command: node ./dist/index.js -h
      - run:
          name: Update metadata
          command: ../metadata/update.js
      - run:
          name: Publish if files are not identical
          command:
            | # HACKS: this uses the last "patch" version from NPM smooshed with the metadata version. there has to be a better way!
            MAJOR_MINOR_VERSION="$(cat ../metadata/index.json | jq -r .pkg.majorMinor)"
            NEXT_NPM_VERSION="$(npx semver -i patch $(npm show @stoplight/cli version))"
            PATCH_VERSION="$(echo $NEXT_NPM_VERSION | cut -d . -f 3)"
            VERSION="$MAJOR_MINOR_VERSION.$PATCH_VERSION"
            npm version "$VERSION"
            cmp --silent ./index.js ./dist/index.js || npm publish --verbose --timing

  deploy_pre-prod:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-production
            kubectl config set-context --current --namespace=pre-prod
      - deploy:
          environment: pre-prod
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  deploy_prod:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-production
      - run: kubectl config set-context --current --namespace=prod
      - deploy:
          environment: prod
      - run:
          name: Trigger release pipeline
          command: |
            curl --request POST \
              --url https://circleci.com/api/v2/project/github/stoplightio/platform-internal/pipeline \
              --header "Circle-Token: $CIRCLE_BOT_TOKEN" \
              --header "content-type: application/json" \
              --data '{"parameters":{"run_default_workflow":false, "run_release_workflow":true}, "tag":"'"production-v2"'"}'
      - slack-orb/notify:
          channel: 'feed-pipeline-deployments, feed-deployments, feed-pipeline-releases'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: pass
          template: success_release
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  rollback_pre-prod:
    # Trigger this job manually using the following command
    # curl -u ${CIRCLECI_TOKEN}: \
    #         -d 'build_parameters[CIRCLE_JOB]=rollback_pre-prod' \
    #        https://circleci.com/api/v1.1/project/github/stoplightio/platform-internal/tree/v2
    executor: node-gcp-build
    resource_class: small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - setup_remote_docker
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-production
             kubectl config set-context --current --namespace=pre-prod
      - rollback:
          environment: pre-prod
      - run:
          name: finish pre-prod rollback
          no_output_timeout: 20m
          command: |
            # TODO: Update slack notifactions to use `notify` job instead of api call here

            #Wait for successful rollout, send a slack message
            if
              OUTPUT1="$(timeout 900 kubectl rollout status -w deployment/worker | sed "s/\"/'/g")";
            then
              echo "No timeout. Deployment was successful"
            else
              echo "pre-prod Deployment has timed out! Sending slack message..."
              EVENTS="$(kubectl describe pod -l app.kubernetes.io/name=pre-prod | awk -v N=2 '/Events:/{++n} n>=N' | sed '1,/Name:/!d' | sed "s/\"/'/g")"
              curl -X POST --data-urlencode 'payload={"text": "```'"$(echo "V2 pre-prod ROLLBACK FAILED\n\n$EVENTS\n\nCIRCLE CI BUILD:$CIRCLE_BUILD_URL\n\nCOMMIT: $(git log --pretty=format:%s -1)")"'```"}' https://hooks.slack.com/services/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 && exit 1
            fi

  rollback_prod:
    # Trigger this job manually using the following command
    # curl -u ${CIRCLECI_TOKEN}: \
    #         -d 'build_parameters[CIRCLE_JOB]=rollback_prod' \
    #        https://circleci.com/api/v1.1/project/github/stoplightio/platform-internal/tree/v2
    executor: node-gcp-build
    resource_class: small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - setup_remote_docker
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-production
      - rollback:
          environment: pre-prod
      - run: kubectl config set-context --current --namespace=prod
      - rollback:
          environment: stoplightio-v2
      - run:
          name: finish prod rollback
          no_output_timeout: 20m
          command: |
            # TODO: Update slack notifactions to use `notify` job instead of api call here

            #If everything was successful, send success message, otherwise send full log and fail job
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-production
            if
              OUTPUT="$(timeout 900 kubectl rollout status -w deployment/worker | sed "s/\"/'/g")"
            then
              echo "No timeout. Rollback was successful"
              ROLLBACK_PROD_IMAGE=$(kubectl get deployment worker -o=jsonpath='{.spec.template.spec.containers[0].image}' | cut -d ":" -f 2)
              printf "$ROLLBACK_PROD_IMAGE" | gcloud --project stoplight-dojo-production secrets versions add prod_image-tag --data-file=-

              curl -X POST --data-urlencode 'payload={"blocks": [{"type": "section","text": {"type": "mrkdwn","text": "* V2 PRODUCTION ROLLBACK SUCCESSFUL*"}},{"type": "section","text": {"type": "mrkdwn","text": "<'"$(echo $CIRCLE_BUILD_URL)"'|CIRCLE CI BUILD>"}},{"type": "section","text": {"type": "mrkdwn","text": "*REVERTED CHANGES*\n'"$(git log --pretty=format:"- %s (%an)" HEAD...production-v2 | sed "s/\'//g" | sed "s/\"//g" | sed 's/(#\([0-9]\{1,\}\))/[<https\:\/\/github.com\/stoplightio\/platform-internal\/pull\/\1|#\1>]/g')"'"}}]}' https://hooks.slack.com/services/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
              DEPLOYED_PRS="$(git log HEAD...production-v2 --pretty=format:"%s" | sed "s/^.*#\([0-9]\{1,\}\))/\1/g" | sed "s/[^0-9]*//g" | sed '/^\s*$/d' | tr '\n' ',' | sed "s/^\(.*\),$/\1/g")"
              curl -X POST -H 'Content-Type: application/json' -d '{"numbers": ['"$(echo $DEPLOYED_PRS)"']}' https://us-central1-stoplight-dojo-production.cloudfunctions.net/TrackDeploys || echo "We failed to report deploys to Eng Metrics, but deploy will continue"
            else
              echo "production rollback has timed out! Sending slack message..."
              EVENTS="$(kubectl describe pod -l app.kubernetes.io/name=stoplightio-v2 | awk -v N=2 '/Events:/{++n} n>=N' | sed '1,/Name:/!d' | sed "s/\"/'/g")"
              curl -X POST --data-urlencode 'payload={"text": "```'"$(echo "V2 PRODUCTION ROLLBACK FAILED\n\n$EVENTS\n\nCIRCLE CI BUILD: $CIRCLE_BUILD_URL")"'```"}' https://hooks.slack.com/services/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 && exit 1
            fi

  create_amplitude_release:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    steps:
      - get-ip-address
      - checkout-and-merge
      - run:
          name: Update metadata
          command: ./packages/metadata/update.js
      - run:
          name: 'Create release in Amplitude'
          command: |
            version="$(cat packages/metadata/index.json | jq -r .release)"
            echo "Creating release in Amplitude for version $version"
            curl -d "version=$version&release_start=$(date '+%F %T-00')&title=$version&platforms=Web" -u $AMPLITUDE_API_KEY:$AMPLITUDE_SECRET_KEY -X POST https://amplitude.com/api/2/release

  run-migrations:
    parameters:
      environment:
        type: string
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            environment=<<parameters.environment>>

            if [[ "$environment" = "stoplightio-v2" || "$environment" = "pre-prod" ]]; then
              CLOUDSDK_CORE_PROJECT=stoplight-dojo-production
            else
              CLOUDSDK_CORE_PROJECT=stoplight-dojo-integration
            fi

            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project $CLOUDSDK_CORE_PROJECT
      - run:
          name: Set env vars
          command: |
            environment=<<parameters.environment>>

            if [[ "$environment" = "stoplightio-v2" ]]; then
              NAMESPACE=prod
            elif [[ "$environment" = "pre-prod" ]]; then
              NAMESPACE=pre-prod
            elif [[ "$environment" = "integration" ]]; then
              NAMESPACE=integration
            else
              PR_NUMBER=$(echo "$CI_PULL_REQUEST" | awk -F/ '{print $NF}')
              NAMESPACE=x-$PR_NUMBER
              environment=x-$PR_NUMBER
            fi

            GIT_COMMIT="$(git rev-parse --short HEAD)"

            echo "export environment=$environment" >> $BASH_ENV
            echo "export GIT_COMMIT=$GIT_COMMIT" >> $BASH_ENV
            echo "export NAMESPACE=$NAMESPACE" >> $BASH_ENV
            echo "export DEPLOYMENT_NAME=$DEPLOYMENT_NAME" >> $BASH_ENV
            echo "export PR=$PR_NUMBER" >> $BASH_ENV
      - run:
          name: make sure this isn't a rollback in integration or prod
          command: |

            if [[ "$environment" = "stoplightio-v2" || "$environment" = "integration" || "$environment" = "pre-prod" ]]; then

              DEPLOYED_COMMIT="$(kubectl get deployment worker -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[*].image}' | cut -d':' -f2)"

              if git merge-base --is-ancestor $GIT_COMMIT $DEPLOYED_COMMIT && [ $GIT_COMMIT != $DEPLOYED_COMMIT ] ; then
                echo "This commit is an ancestor of the currently deployed commit! Please contact DevOps if you're trying to rollback!"
                exit 1
              fi
            fi
      - run:
          name: snapshot prod db
          command: |
            environment=<<parameters.environment>>
            GIT_COMMIT="$(git rev-parse --short HEAD)"

            if [[ "$environment" = "stoplightio-v2" ]]; then
              # Take snapshot of production database
              gcloud sql backups create --instance stoplightio-v2-postgres --project stoplight-dojo-production --description="stoplightio-v2 snapshot from right before $GIT_COMMIT deployment"
            elif [[ "$environment" = "integration" ]]; then
              # Take snapshot of database
              echo "Temporarily skipping integration backups..."
              # gcloud sql backups create --async --instance integration-postgres --project stoplight-dojo-integration --description="integration snapshot from right before $GIT_COMMIT deployment"
            fi
      - run:
          name: render template
          command: |
            cd stoplight-k8s/platform

            if [[ "$environment" = "stoplightio-v2" ]]; then
              export VALUES="values/prod.yaml"

            elif [[ "$environment" = "integration" ]]; then
              export VALUES="values/integration.yaml"

            elif [[ "$environment" = "pre-prod" ]]; then
              export VALUES="values/pre-prod.yaml"

            else
              # pr envs
              /bin/bash -ex render-values.sh pr
              export VALUES="values.yaml"

            fi

            GIT_COMMIT="$(git rev-parse --short HEAD)"
            helm template $environment . -f "${VALUES}" -s templates/migrate_job.yml --set-string migrate_job=true --set imageTag=$GIT_COMMIT --set originCert.crt="foo" --set originCert.key="bar" > output.yaml
      - run:
          name: apply template
          command: |
            # since we're storing the image tag in gcloud, the yaml files
            # are TF templates, sed is being used here to act as a simplified
            # template renderer to replace TF in this case.
            sed -i "s/\${IMAGE_TAG}/${GIT_COMMIT}/g" stoplight-k8s/platform/output.yaml

            kubectl delete jobs/migrate-job -n $NAMESPACE || :
            kubectl apply -f stoplight-k8s/platform/output.yaml -n $NAMESPACE
      - run:
          name: wait for migration to complete
          no_output_timeout: 60m
          command: |
            while [[ "$(kubectl get job migrate-job -n $NAMESPACE -o jsonpath={.status.succeeded})" != "1" ]]; do
              sleep 3
            done

  pipeline-gate:
    docker:
      - image: curlimages/curl:7.69.1
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    resource_class: small
    steps:
      - run:
          name: Only run on PR, v2, or stable branches
          command: |
            echo "Pull request is $CI_PULL_REQUEST"
            echo "Branch is $CIRCLE_BRANCH"
            echo "Tag is $CIRCLE_TAG"

            echo "$CIRCLE_TAG" | grep -Eq '\d+\.\d+\.\d+-' && export VALID_TAG=true

            if [[ "$CI_PULL_REQUEST" != "" || "$CIRCLE_BRANCH" == "v2" || "$VALID_TAG" != "" ]]; then
                echo "Running pipeline for commit $CIRCLE_SHA1"

            else
                echo "Pipeline only builds on Pull Requests, the primary v2 branch, and all stable branches."
                curl --request POST \
                --url https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel \
                --header "Circle-Token: ${CIRCLE_BOT_TOKEN}"
            fi

  spin-up-review-env:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - run:
          name: Check if PR
          command: |
            # Skip if not PR
            if [ ! "$CI_PULL_REQUEST" ]; then
                circleci-agent step halt
            else
              # This is needed in order to persist to other steps
              echo "export PR_NUMBER=`echo $CIRCLE_PULL_REQUESTS| tr "," "\n" | awk -F/ '{print $NF}' | sort -r | head -1`" >> $BASH_ENV
            fi
      - checkout-and-merge
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: spin up pr env
          command: |
            export GIT_COMMIT="$(git rev-parse --short HEAD)"

            cd stoplight-k8s/platform
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration

            # Delete old namespace if smurf naming found
            if kubectl -n x-"${PR_NUMBER}" get deployments | grep "${PR_NUMBER}"; then
              echo "Tearing down legacy PR namespace"
              PR="${PR_NUMBER}" ./pr-down.sh
            fi

            # Bring up new pr environment
            PR="${PR_NUMBER}" ./pr-up.sh

  deploy-cloud-functions:
    parameters:
      environment:
        type: string
    resource_class: medium
    executor: node-gcp-build
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
    steps:
      - get-ip-address
      - checkout-and-merge
      - get-node-modules
      - run: git config core.abbrev 7
      - gcloud-authenticate
      - run:
          name: build cloud functions
          command: |
            yarn build-cloud-functions
      - run:
          name: deploy cloud functions
          command: |
            export ENV=<<parameters.environment>>

            if [[ "${ENV}" == "pr" ]]; then
              export ENV="x-$(echo "$CI_PULL_REQUEST" | awk -F/ '{print $NF}')"
            fi

            # Deploy cloud functions
            ./cloud-functions/deploy.py -e ${ENV}

  spin-down-review-env:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-small
    steps:
      - get-ip-address
      - checkout
      - gcloud-authenticate
      - run:
          name: spin down pr env
          no_output_timeout: 20m
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration
            cd stoplight-k8s/platform
            PR="${PR_NUMBER}" ./pr-down.sh

  release-replicated:
    parameters:
      channel:
        type: string
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    environment:
      CHANNEL: <<parameters.channel>>
    steps:
      - get-ip-address
      - checkout-and-merge
      - run: git config core.abbrev 7
      - when:
          condition: << pipeline.git.tag >>
          steps:
            - run:
                name: validate tag
                command: |
                  git fetch --all
                  GIT_BRANCH_OUTPUT="$(git branch -a --contains $CIRCLE_TAG)"
                  if ! echo "$GIT_BRANCH_OUTPUT" | grep stable; then
                    echo "Please create a stable branch to release a tagged artifact. Exiting..."
                    exit 1
                  fi
                  GIT_BRANCH="$(echo "$GIT_BRANCH_OUTPUT" | grep stable | tr -d ' ')"
                  GIT_BRANCH=${GIT_BRANCH/remotes\/origin\//}
                  echo "Detected git branch: $GIT_BRANCH"
                  RELEASE_BRANCH_TAG=${GIT_BRANCH/stable\//}
                  if ! [[ "$CIRCLE_TAG" = ${RELEASE_BRANCH_TAG}* ]]; then
                    echo "Tag $CIRCLE_TAG can't be created from branch ${GIT_BRANCH}! Exiting..."
                    exit 1
                  fi
      - run:
          name: install dependencies
          command: |
            curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
            sudo apt update && sudo apt install gettext-base
      - run: |
          #export CHANNEL=<<parameters.channel>>
          cd infrastructure/replicated-packaging/platform/kots/
          make release

  wait-for-integration-jobs:
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    description: Wait until no other builds in this project are running the provided job name, then proceed.
    steps:
      - get-ip-address
      - checkout
      - wait-for-jobs:
          job-names:
            run-migrations-integration deploy_integration integration-e2e-api-tests integration-e2e-cli-tests
            terraform-plan-integration terraform-apply-integration approve_integration_terraform
            integration-e2e-playwright-tests integration-e2e-playwright-tests-flaky-force-success

  e2e-wait-for-testrail-tests:
    parameters:
      slug:
        type: string
        description: slug that prefixes test jobs that report to testrail (ie. integration, pr)
    docker:
      - image: *default-node-image
        auth:
          username: stoplightreadonly
          password: $DOCKERHUB_PASSWORD
    description: Wait for all tests that report results to TestRail to complete so we can close the run
    steps:
      - get-ip-address
      - checkout
      - wait-for-jobs:
          job-names:
            <<parameters.slug>>-e2e-api-tests <<parameters.slug>>-e2e-playwright-tests
            <<parameters.slug>>-e2e-playwright-tests-flaky-force-success
          only-current-build: true

  disable-emails-during-tests:
    executor: node-gcp-build
    resource_class: stoplight/self-hosted-runner-medium # seeding workspaces was running OOM on small
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - gcloud-authenticate
      - run:
          name: authenticate to k8s cluster
          command: |
            gcloud container clusters get-credentials platform-cluster-private --zone us-central1-a --project stoplight-dojo-integration
      - env-var-by-branch
      - run:
          name: Disable emails
          command: |
            kubectl set env deployment/${JOB_PREFIX}worker SL_EMAIL_HOST- -n $NAMESPACE
            kubectl set env deployment/${JOB_PREFIX}essential-worker SL_EMAIL_HOST- -n $NAMESPACE

            # Double the amount of workers in the environment
            ORIGINAL_WORKER_COUNT=$( kubectl get deployment/worker -o=jsonpath='{.status.replicas}' -n $NAMESPACE )
            ELASTIC_WORKER_COUNT=$((ORIGINAL_WORKER_COUNT * 2))
            echo "export ORIGINAL_WORKER_COUNT=$ORIGINAL_WORKER_COUNT" >> $BASH_ENV

            echo "Scaling to $ELASTIC_WORKER_COUNT workers"
            kubectl scale deployment/worker --replicas=$ELASTIC_WORKER_COUNT -n $NAMESPACE
      - run:
          name: Seed example workspaces
          command: |
            PR_NUMBER=`echo $CIRCLE_PULL_REQUESTS| tr "," "\n" | awk -F/ '{print $NF}' | sort -r | head -1`
            yarn qa seed --targetPR $PR_NUMBER
      - wait-for-jobs:
          job-names:
            pr-e2e-testrail-open-run pr-e2e-cli-tests pr-e2e-api-tests pr-e2e-playwright-tests
            pr-e2e-playwright-tests-flaky-force-success
          only-current-build: true
      - run:
          name: Enable emails
          when: always
          command: |
            kubectl set env deployment/${JOB_PREFIX}worker SL_EMAIL_HOST="smtp.sendgrid.net" -n $NAMESPACE
            kubectl set env deployment/${JOB_PREFIX}essential-worker SL_EMAIL_HOST="smtp.sendgrid.net" -n $NAMESPACE
            kubectl scale deployment/worker --replicas=$ORIGINAL_WORKER_COUNT -n $NAMESPACE

  captain-queso:
    resource_class: stoplight/self-hosted-runner-small
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - env-var-by-branch
      - run:
          name: post slack reports
          no_output_timeout: 10m
          command: |
            cd packages/qa
            yarn --silent testrail postSlackReports

  e2e-testrail-open-run:
    resource_class: stoplight/self-hosted-runner-small
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - env-var-by-branch
      - run:
          name: open testrail test run
          no_output_timeout: 2m
          command: |
            cd packages/qa
            STALE_RUNS_CLOSED=$(yarn --silent testrail closeStaleRuns --summary 1)
            echo -e "Closed stale test runs:\n${STALE_RUNS_CLOSED}"
            # Create standard test run
            TEST_RUN_ID=$(yarn --silent testrail addRun --automation_type_id 1,2,3 --target_id 0,1 --flaky false --csv 1)
            TEST_RUN_URL=https://stoplightqa.testrail.io/index.php?/runs/view/${TEST_RUN_ID}
            echo "Created TestRail test run #${TEST_RUN_ID}: ${TEST_RUN_URL}"
            echo ${TEST_RUN_ID} > ../../testrail-run-id
            # Create flaky test run
            TEST_RUN_ID_FLAKY=$(yarn --silent testrail addRun --automation_type_id 1,2,3 --target_id 0,1 --flaky true --csv 1)
            TEST_RUN_URL_FLAKY=https://stoplightqa.testrail.io/index.php?/runs/view/${TEST_RUN_ID_FLAKY}
            echo "Created TestRail flaky test run #${TEST_RUN_ID_FLAKY}: ${TEST_RUN_URL_FLAKY}"
            echo ${TEST_RUN_ID_FLAKY} > ../../testrail-run-id-flaky
      - persist_to_workspace:
          root: .
          paths:
            - testrail-run-id
            - testrail-run-id-flaky
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  e2e-testrail-close-run:
    resource_class: stoplight/self-hosted-runner-small
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - env-var-by-branch
      - attach_workspace:
          at: .
      - run:
          name: close testrail test run
          no_output_timeout: 2m
          command: |
            cd packages/qa
            # skip closing testrail run if one wasn't opened
            if [ -f ../../testrail-run-id ] && [ $(cat ../../testrail-run-id) -gt 0 ]; then
              TEST_RUN_ID=$(cat ../../testrail-run-id)
              echo "TEST_RUN_ID: ${TEST_RUN_ID}"
              # Close the run only if it is completely reported and there are no failures
              # We clean up stale open runs on every reported execution after they've been inactive X hours
              yarn --silent testrail closeRun --soft ${TEST_RUN_ID} || true
            else
              echo -e "Didn't close testrail test run. ../../testrail-run-id doesn't exist or contains 0"
            fi
            # skip closing flaky testrail run if one wasn't opened
            if [ -f ../../testrail-run-id-flaky ] && [ $(cat ../../testrail-run-id-flaky) -gt 0 ]; then
              TEST_RUN_ID_FLAKY=$(cat ../../testrail-run-id-flaky)
              echo "TEST_RUN_ID_FLAKY: ${TEST_RUN_ID_FLAKY}"
              # Close the run. Flaky tests force success, so they won't be re-run anyway.
              yarn --silent testrail closeRun ${TEST_RUN_ID_FLAKY} || true
            else
              echo -e "Didn't close testrail flaky test run. ../../testrail-run-id-flaky doesn't exist or contains 0"
            fi
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  e2e-api-test:
    resource_class: stoplight/self-hosted-runner-medium-plus
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - env-var-by-branch
      - attach_workspace:
          at: .
      - run:
          name: run e2e api tests
          command: |
            TESTRAIL_RUN_ID=$(<./testrail-run-id) yarn e2e-api start --maxWorkers=2
      - store_test_results:
          path: ./packages/e2e-api/reports/junit
      - store_artifacts:
          path: ./packages/e2e-api/reports/junit
      - store_artifacts:
          path: ./packages/e2e-api/reports/html
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  e2e-cli-test:
    resource_class: stoplight/self-hosted-runner-medium
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    steps:
      - get-ip-address
      - env-var-by-branch
      - run:
          name: Run E2E CLI tests
          command: |
            yarn e2e-cli jest --reporters=default --reporters="jest-junit"
          environment:
            JEST_JUNIT_OUTPUT_DIR: ./reports/junit/
      - store_test_results:
          path: ./packages/e2e-cli/reports/junit
      - store_artifacts:
          path: ./packages/e2e-cli/reports/junit
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  e2e-playwright-test:
    resource_class: stoplight/self-hosted-runner-large # one node, 4 cores - playwright handles parallelism
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    parameters:
      workers:
        type: integer
        description: Number of concurrent tests to run in parallel
        default: 4
    steps:
      - get-ip-address
      - env-var-by-branch
      - attach_workspace:
          at: .
      - run:
          name: run playwright tests
          no_output_timeout: 5m
          command: |
            cd packages/e2e-playwright
            PLAYWRIGHT_BROWSERS_PATH=/root/project/pw-browsers \
            TESTRAIL_RUN_ID=$(<../../testrail-run-id) \
            yarn start --workers <<parameters.workers>>
      - run:
          name: compress reporter debug output
          when: always
          command: |
            cd packages/e2e-playwright/reports
            tar -cvzf debug.tar.gz debug
            rm -r debug
      - store_test_results:
          path: packages/e2e-playwright/reports/junit
      - store_artifacts:
          path: packages/e2e-playwright/reports/artifacts
      - store_artifacts:
          path: packages/e2e-playwright/reports/html
      - store_artifacts:
          path: packages/e2e-playwright/reports/debug.tar.gz
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  e2e-playwright-test-flaky-force-success:
    resource_class: stoplight/self-hosted-runner-medium
    docker:
      - image: quay.io/stoplight/e2e-test-run:$CIRCLE_SHA1
        auth:
          username: stoplight+newcircleci
          password: $QUAY_PASSWORD
    parameters:
      workers:
        type: integer
        description: Number of concurrent tests to run in parallel
        default: 2
    steps:
      - get-ip-address
      - env-var-by-branch
      - attach_workspace:
          at: .
      - run:
          name: run flaky playwright tests, forcing success
          no_output_timeout: 5m
          command: |
            cd packages/e2e-playwright
            PLAYWRIGHT_BROWSERS_PATH=/root/project/pw-browsers \
            TESTRAIL_RUN_ID=$(<../../testrail-run-id-flaky) \
            ./run-tests-force-success.sh start-flaky --workers <<parameters.workers>>
      - run:
          name: compress reporter debug output
          when: always
          command: |
            cd packages/e2e-playwright/reports
            tar -cvzf debug.tar.gz debug
            rm -r debug
      - store_test_results:
          path: packages/e2e-playwright/reports/junit
      - store_artifacts:
          path: packages/e2e-playwright/reports/artifacts
      - store_artifacts:
          path: packages/e2e-playwright/reports/html
      - store_artifacts:
          path: packages/e2e-playwright/reports/debug.tar.gz
      - slack-orb/notify:
          channel: 'feed-pipeline-failures, feed-deployments'
          user_mapping_file: .circleci/slackid-gh-user-mapping.json
          branch_pattern: v2
          event: fail
          template: fail_v2_deploy

  sentry-release:
    # https://docs.sentry.io/product/releases/setup/release-automation/circleci
    docker:
      - image: cimg/base:2021.07
    parameters:
      sentry-project:
        type: string
        description: The name of the project in sentry
    environment:
      SENTRY_ORG: stoplightio
      SENTRY_ENVIRONMENT: production
    steps:
      - get-ip-address
      - checkout
      - run:
          name: Create release and notify Sentry of deploy
          command: |
            set -ex
            curl -sL https://sentry.io/get-cli/ | bash

            if [ "$SENTRY_AUTH_TOKEN" = "" ]; then
              echo "Skipping sentry-release: SENTRY_AUTH_TOKEN not defined"
              exit 1
            fi

            export SENTRY_RELEASE=$(sentry-cli releases propose-version)
            export SENTRY_PROJECT="<<parameters.sentry-project>>"

            sentry-cli releases new -p $SENTRY_PROJECT $SENTRY_RELEASE
            sentry-cli releases set-commits $SENTRY_RELEASE --auto
            sentry-cli releases finalize $SENTRY_RELEASE
            sentry-cli releases deploys $SENTRY_RELEASE new -e $SENTRY_ENVIRONMENT

  setup-workspace:
    resource_class: medium
    docker:
      - image: *default-node-image
    environment:
      PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: 1
      MAIN_BRANCH_NAME: v2
    steps:
      - checkout-and-merge
      # install and cache node_modules
      - get-node-modules
      - nx/set-shas
      - run: mkdir -p circleci-workspace

workflows:
  version: 2

  release:
    when: << pipeline.parameters.run_release_workflow >>
    jobs:
      - create_amplitude_release
      - sentry-release:
          name: sentry-release-platform-services-activity
          sentry-project: platform-services-activity
      - sentry-release:
          name: sentry-release-platform-services-billing
          sentry-project: platform-services-billing
      - sentry-release:
          name: sentry-release-platform-services-api-design
          sentry-project: platform-services-api-design
      - sentry-release:
          name: sentry-release-platform-services-gateway
          sentry-project: platform-services-gateway
      - sentry-release:
          name: sentry-release-platform-services-groups
          sentry-project: platform-services-groups
      - sentry-release:
          name: sentry-release-platform-services-user-images
          sentry-project: platform-services-user-images
      - sentry-release:
          name: sentry-release-platform-services-worker-publisher
          sentry-project: platform-services-worker-publisher
      - sentry-release:
          name: sentry-release-platform-services-vcs-integrations
          sentry-project: platform-services-vcs-integrations

  rollback_workflow:
    when: << pipeline.parameters.run_rollback_workflow >>
    jobs:
      - rollback_workflow:
          context: slack-secrets

  test_failure:
    jobs:
      - test_failure

  default:
    when: << pipeline.parameters.run_default_workflow >>
    jobs:
      - pipeline-gate:
          <<: *tag_only
      - setup-workspace:
          requires:
            - pipeline-gate
          <<: *tag_only
      - terraform:
          name: terraform-plan-integration
          environment: integration
          context: slack-secrets
          action: plan
          requires:
            - wait-for-integration-jobs
      - approve_integration_terraform:
          type: approval
          requires:
            - wait-for-integration-jobs
      - terraform:
          name: terraform-apply-integration
          environment: integration
          action: apply
          requires:
            - approve_integration_terraform
            - terraform-plan-integration
      - terraform:
          name: terraform-plan-pre-prod
          environment: pre-prod
          action: plan
          filters:
            branches:
              only:
                - v2
          requires:
            - integration-e2e-playwright-tests
            - integration-e2e-playwright-tests-flaky-force-success
            - integration-e2e-api-tests
            - integration-e2e-cli-tests
            - integration-unit-tests
            - integration-graphql-tests
      - terraform:
          name: terraform-apply-pre-prod
          environment: pre-prod
          action: apply
          requires:
            - terraform-plan-pre-prod
      # Test goes here!
      - terraform:
          name: terraform-plan-prod
          environment: stoplightio-v2
          action: plan
          filters:
            branches:
              only:
                - v2
          requires:
            - terraform-apply-pre-prod
      - approve_prod_terraform:
          type: approval
          filters:
            branches:
              only:
                - v2
          requires:
            - terraform-apply-pre-prod
      - terraform:
          name: terraform-apply-prod
          environment: stoplightio-v2
          action: apply
          requires:
            - approve_prod_terraform
            - terraform-plan-prod
      - terraform-preview:
          context: slack-secrets
          requires:
            - setup-workspace
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      # - deploy-cloud-functions:
      #     name: deploy-cloud-functions-pr
      #     requires:
      #       - setup-workspace
      #     environment: pr
      #     filters:
      #       branches:
      #         ignore:
      #           - v2
      #           - /stable\/.*/
      # - deploy-cloud-functions:
      #     name: deploy-cloud-functions-integration
      #     requires:
      #       - run-migrations-integration
      #     environment: integration
      #     filters:
      #       branches:
      #         only:
      #           - v2
      # - deploy-cloud-functions:
      #     name: deploy-cloud-functions-pre-prod
      #     requires:
      #       - run-migrations-pre-prod
      #     environment: pre-prod
      #     filters:
      #       branches:
      #         only:
      #           - v2
      # - deploy-cloud-functions:
      #     name: deploy-cloud-functions-prod
      #     requires:
      #       - run-migrations-prd
      #     environment: stoplightio-v2
      #     filters:
      #       branches:
      #         only:
      #           - v2
      - build_cli:
          requires:
            - setup-workspace
          <<: *tag_only
          filters:
            branches:
              only:
                - v2
                - /stable\/.*/
      - lint-and-type-check:
          requires:
            - setup-workspace
          <<: *tag_only
      - push-on-prem-release:
          requires:
            - pipeline-gate
            - setup-workspace
            - docker-build-yjs
            - docker-build-worker
            - docker-build-stoplight-utility
            - docker-build-public-api
            - docker-build-on-prem-init
            - docker-build-ninja
            - docker-build-mocks
            - docker-build-migrate-job
            - docker-build-micro-workspaces
            - docker-build-micro-worker-publisher
            - docker-build-micro-vcs-integrations
            - docker-build-micro-user-images
            - docker-build-micro-groups
            - docker-build-micro-gateway
            - docker-build-micro-billing
            - docker-build-micro-auth
            - docker-build-micro-api-design
            - docker-build-micro-activity
            - docker-build-init
            - docker-build-graphql-api
            - docker-build-e2e-test
            - docker-build-cors-proxy
            - build-and-deploy-storybook
            - release-replicated-beta
          <<: *tag_only
          filters:
            tags:
              ignore:
                - production
                - production-v2
            branches:
              ignore: /.*/
      - build-and-deploy-storybook:
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-on-prem-init:
          requires:
            - setup-workspace
          <<: *tag_only
          filters:
            tags:
              ignore:
                - production
                - production-v2
            branches:
              ignore: /.*/
      - docker-build-stoplight-utility:
          requires:
            - setup-workspace
          <<: *tag_only
          filters:
            tags:
              ignore:
                - production
                - production-v2
            branches:
              ignore: /.*/
      - docker-build-service:
          name: docker-build-worker
          image-name: worker
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-migrate-job
          image-name: migrate-job
          package-name: hasura
          gcr-auth: true
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-graphql-api
          image-name: graphql-api
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-yjs
          image-name: yjs
          package-name: yjs-api
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-public-api
          image-name: public-api
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-ninja
          image-name: ninja
          executor-size: xlarge
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-mocks
          image-name: mocks
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-cors-proxy
          image-name: cors-proxy
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-e2e-test
          image-name: e2e-test-run
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-service:
          name: docker-build-init
          image-name: init
          package-name: NONE
          gcr-auth: true
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-gateway
          image-name: stoplight-service-gateway
          service-name: gateway
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-auth
          image-name: stoplight-service-auth
          service-name: auth
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice-auth-oauth:
          name: docker-build-microservice-auth-oauth
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-api-design
          image-name: stoplight-service-api-design
          service-name: api-design
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-groups
          image-name: stoplight-service-groups
          service-name: groups
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-workspaces
          image-name: stoplight-service-workspaces
          service-name: workspaces
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-user-images
          image-name: stoplight-service-user-images
          service-name: user-images
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-activity
          image-name: stoplight-service-activity
          service-name: activity
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-billing
          image-name: stoplight-service-billing
          service-name: billing
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-worker-publisher
          image-name: stoplight-service-worker-publisher
          service-name: worker-publisher
          requires:
            - setup-workspace
          <<: *tag_only
      - docker-build-microservice:
          name: docker-build-micro-vcs-integrations
          image-name: stoplight-service-vcs-integrations
          service-name: vcs-integrations
          requires:
            - setup-workspace
          <<: *tag_only
      - test:
          name: pr-unit-tests
          context: slack-secrets
          requires:
            - setup-workspace
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - test:
          name: integration-unit-tests
          context: slack-secrets
          requires:
            - setup-workspace
          filters:
            branches:
              only:
                - v2
      - sonarcloud-report:
          name: integration-sonarcloud-report
          requires:
            - integration-unit-tests
          filters:
            branches:
              only:
                - v2
      - sonarcloud-report:
          name: pr-sonarcloud-report
          requires:
            - pr-unit-tests
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - test-graphql:
          name: pr-graphql-tests
          context: slack-secrets
          requires:
            - docker-build-worker
            - docker-build-public-api
            - docker-build-graphql-api
            - docker-build-migrate-job
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - test-graphql:
          name: integration-graphql-tests
          context: slack-secrets
          requires:
            - docker-build-init
            - docker-build-worker
            - docker-build-yjs
            - docker-build-public-api
            - docker-build-ninja
            - docker-build-mocks
            - docker-build-cors-proxy
            - docker-build-graphql-api
            - docker-build-migrate-job
            - docker-build-micro-gateway
            - docker-build-micro-auth
            - docker-build-micro-api-design
            - docker-build-micro-groups
            - docker-build-micro-workspaces
            - docker-build-micro-user-images
            - docker-build-micro-activity
            - docker-build-micro-billing
            - docker-build-micro-worker-publisher
            - docker-build-micro-vcs-integrations
          filters:
            branches:
              only:
                - v2
      - spin-up-review-env:
          requires:
            - docker-build-init
            - docker-build-worker
            - docker-build-yjs
            - docker-build-public-api
            - docker-build-ninja
            - docker-build-mocks
            - docker-build-cors-proxy
            - docker-build-graphql-api
            - docker-build-migrate-job
            - docker-build-micro-gateway
            - docker-build-microservice-auth-oauth
            - docker-build-micro-auth
            - docker-build-micro-api-design
            - docker-build-micro-groups
            - docker-build-micro-workspaces
            - docker-build-micro-user-images
            - docker-build-micro-activity
            - docker-build-micro-billing
            - docker-build-micro-worker-publisher
            - docker-build-micro-vcs-integrations
            # - deploy-cloud-functions-pr
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - run-migrations:
          name: run-migrations-pr
          requires:
            - spin-up-review-env
          environment: pr
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - wait-for-integration-jobs:
          requires:
            - docker-build-init
            - docker-build-worker
            - docker-build-yjs
            - docker-build-public-api
            - docker-build-ninja
            - docker-build-mocks
            - docker-build-cors-proxy
            - docker-build-graphql-api
            - docker-build-migrate-job
            - docker-build-micro-gateway
            - docker-build-micro-auth
            - docker-build-micro-api-design
            - docker-build-micro-groups
            - docker-build-micro-workspaces
            - docker-build-micro-user-images
            - docker-build-micro-activity
            - docker-build-micro-billing
            - docker-build-micro-worker-publisher
            - docker-build-micro-vcs-integrations
          filters:
            branches:
              only:
                - v2
      - disable-emails-during-tests:
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-cli-test:
          name: pr-e2e-cli-tests
          context: slack-secrets
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-testrail-open-run:
          name: pr-e2e-testrail-open-run
          context: slack-secrets
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
            - pr-e2e-cli-tests # temp. serialize e2e test suites
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-wait-for-testrail-tests:
          name: pr-e2e-wait-for-testrail-tests
          requires:
            - pr-e2e-testrail-open-run
          slug: pr
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-api-test:
          name: pr-e2e-api-tests
          context: slack-secrets
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
            - pr-e2e-testrail-open-run
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-playwright-test:
          name: pr-e2e-playwright-tests
          context: slack-secrets
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
            - pr-e2e-testrail-open-run
            - pr-e2e-api-tests # temp. serialize e2e test suites
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-playwright-test-flaky-force-success:
          name: pr-e2e-playwright-tests-flaky-force-success
          context: slack-secrets
          requires:
            - docker-build-e2e-test
            - run-migrations-pr
            - pr-e2e-testrail-open-run
            - pr-e2e-api-tests # temp. serialize e2e test suites (ok to run with non-flaky playwright though)
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - e2e-testrail-close-run:
          name: pr-e2e-testrail-close-run
          context: slack-secrets
          requires:
            - pr-e2e-wait-for-testrail-tests
            - pr-e2e-api-tests
            - pr-e2e-playwright-tests
            - pr-e2e-playwright-tests-flaky-force-success
          filters:
            branches:
              ignore:
                - v2
                - /stable\/.*/
      - run-migrations:
          name: run-migrations-integration
          requires:
            - terraform-apply-integration
          environment: integration
          filters:
            branches:
              only:
                - v2
      - deploy_integration:
          context: slack-secrets
          requires:
            - run-migrations-integration
          filters:
            branches:
              only:
                - v2
      - e2e-cli-test:
          name: integration-e2e-cli-tests
          context: slack-secrets
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - docker-build-e2e-test
          filters:
            branches:
              only:
                - v2
      - e2e-testrail-open-run:
          name: integration-e2e-testrail-open-run
          context: slack-secrets
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - docker-build-e2e-test
            - integration-e2e-cli-tests # temp. serialize e2e test suites
          filters:
            branches:
              only:
                - v2
      - e2e-wait-for-testrail-tests:
          name: integration-e2e-wait-for-testrail-tests
          requires:
            - integration-e2e-testrail-open-run
          slug: integration
          filters:
            branches:
              only:
                - v2
      - e2e-api-test:
          name: integration-e2e-api-tests
          context: slack-secrets
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - docker-build-e2e-test
            - integration-e2e-testrail-open-run
            - integration-e2e-cli-tests # temp. serialize e2e test suites
          filters:
            branches:
              only:
                - v2
      - e2e-playwright-test:
          context: slack-secrets
          name: integration-e2e-playwright-tests
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - docker-build-e2e-test
            - integration-e2e-testrail-open-run
            - integration-e2e-api-tests # temp. serialize e2e test suites
          filters:
            branches:
              only:
                - v2
      - e2e-playwright-test-flaky-force-success:
          context: slack-secrets
          name: integration-e2e-playwright-tests-flaky-force-success
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - docker-build-e2e-test
            - integration-e2e-testrail-open-run
            - integration-e2e-api-tests # temp. serialize e2e test suites (ok to run with non-flaky playwright though)
          filters:
            branches:
              only:
                - v2
      - e2e-testrail-close-run:
          name: integration-e2e-testrail-close-run
          context: slack-secrets
          requires:
            - integration-e2e-wait-for-testrail-tests
            - integration-e2e-api-tests
            - integration-e2e-playwright-tests
            - integration-e2e-playwright-tests-flaky-force-success
          filters:
            branches:
              only:
                - v2
      - publish_cli_integration:
          requires:
            - deploy_integration
            # - deploy-cloud-functions-integration
            - build_cli
          filters:
            branches:
              only:
                - v2
      - bless_image:
          name: bless-integration-image
          blessed-image-tag: integration
          gcp-image-secret: integration_image-tag
          gcp-project: stoplight-dojo-integration
          requires:
            - integration-e2e-playwright-tests
            - integration-e2e-playwright-tests-flaky-force-success
            - integration-e2e-api-tests
            - integration-e2e-cli-tests
            - integration-unit-tests
            - integration-graphql-tests
          filters:
            branches:
              only:
                - v2
      - run-migrations:
          name: run-migrations-pre-prod
          requires:
            - terraform-apply-prod
          environment: pre-prod
      - deploy_pre-prod:
          context: slack-secrets
          requires:
            - run-migrations-pre-prod
      - run-migrations:
          name: run-migrations-prd
          requires:
            - deploy_pre-prod
            # - deploy-cloud-functions-pre-prod
          environment: stoplightio-v2
      - deploy_prod:
          context: slack-secrets
          requires:
            - run-migrations-prd
      - bless_image:
          name: bless-prod-image
          blessed-image-tag: production-v2
          gcp-image-secret: prod_image-tag
          gcp-project: stoplight-dojo-production
          requires:
            - deploy_prod
            # - deploy-cloud-functions-prod
      - publish_catalog_api_pr:
          requires:
            - setup-workspace
          filters:
            branches:
              only:
                - v2
      - publish_cli_prod:
          requires:
            - deploy_prod
            # - Deploy-cloud-functions-prod
            - build_cli
          filters:
            branches:
              only:
                - v2
      - release-replicated:
          name: release-replicated-unstable
          requires:
            - setup-workspace
          channel: Unstable
          filters:
            branches:
              only:
                - replicated
      - release-replicated:
          name: release-replicated-beta
          requires:
            - setup-workspace
          channel: Beta
          <<: *tag_only
          filters:
            tags:
              ignore:
                - production
                - production-v2
            branches:
              ignore: /.*/
      - publish_cli_stable:
          requires:
            - docker-build-init
            - build_cli
          filters:
            branches:
              only:
                - /stable\/.*/

  captain_queso:
    when: << pipeline.parameters.run_captain_queso >>
    jobs:
      - setup-workspace:
          <<: *tag_only
      - docker-build-service:
          name: docker-build-e2e-test
          image-name: e2e-test-run
          requires:
            - setup-workspace
          <<: *tag_only
      - captain-queso:
          name: run captain queso
          requires:
            - docker-build-e2e-test
